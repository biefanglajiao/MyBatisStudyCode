# 第四章 关联映射与缓存

## 表与表之间的关联映射关系：

（数据库做好外键连接）

> 一对一<br>
> > 一个数据表中<font color=red>一条</font>记录最多可以和另一个数据表中<font color=red>一个</font>记录相关：一个人一张身份证
>
> 一对多<br>
> > 主键数据表中一条记录与另外一个数据表的多条记录相关，但另外一个数据表的记录只能与主键数据表中某一记录相关：一个户口本里有好多人，一个人只属于一个户口本
> 
> 多对多<br>
> > 一个数据表中一条记录可以与另外一个数据表中任意数量记录有关，反之亦然： 一个学生有多个老师，反之亦然

### 一对一
```java
class Person{
    xxxxxx；
    Card type;
}
class Card{
    xxxxxx；
    Person name;   
}
```

#### 使用《association》标签实现

重要属性：<br>

- property:  指定映射到的<font color=red>实体类对象的属性</font>，与表字段一一对应<br>- column: 用于指定表中对应的字段（列）<br>- javaType：用于指定映射到实体对象的属性的类型(哪个类)（pojo）<br>- select: 用于制定引入的嵌套查询的子sql语句
*<font color=red>注意 涉及到映射的文件要写全类名</font>*
#### 配置方式 :
> 需求：根据人的 id查询人的信息以及对应的身份证信息<br><font color=red>要在数据库中创建好对应的外键关系</font>

person表

> <font color=red>表的外键是另一个表的主键</font>

| id（主） | name | age  | sex  | caedid(card表中id的外键) |
| -------- | ---- | ---- | ---- | ------------------------ |

card表

| id（主） | card |
| -------- | ---- |

- Person类

```java
public class Person {
    private  Integer id; //主键id
    private String name;//姓名
    private   Integer age;//年龄
    private  String sex;//性别
    private  Card card;//人员关联证件
//getset tostring
}
```
- Card类

``` java
public class Card {
    private Integer id;//主键id
    private String card;//身份证号码
    //getset tostring
```



##### 嵌套查询方式>先执行第一条 根据结果第二条

> SELECT * from person WHERE id=X
>
> select * from card where id=x
>
> x的值为第一条sql的cardid的值

 <font color=yellow>注意：</font>person中cardid是card中id的外键 （<font color=red>表的外键是另一个表的主键</font>）以此达到对应目的

1. 编写cardMapper.xml和personMapper.xml
2. 修改mybatis-config.xml文件（添加配置）
3. 测试用例实践

###### cardMapper.xml

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cardMapper.xml">
<!--    根据id查询对应身份证号-->
    <select id="selectbyid" parameterType="Integer" resultType="org.example.yiduiyi.Card">
        select * from card where id=#{id}
    </select>
</mapper>
```

###### personMapper.xml

```java
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="personMapper.xml">
<!--    查询个人信息-->
    <!--        结果集映射-->
    <resultMap id="resultmap" type="org.example.yiduiyi.Person">
<!--主键列用id-->
        <id  property="id" column="id"/>
<!--        非主键列用result-->
        <result property="name" column="name"/>
        <result property="age" column="age"/>
        <result property="sex" column="sex"/>
<!--        子查询映射  {property}给card属性赋值(private  Card card;//人员关联证件) 赋值的类型来源于{javaType}Card类-->
<!--        {sleclct}写对应的子查询语句 {column}数据来源于那个表-->
        <association property="card" column="cardid" javaType="org.example.yiduiyi.Card" select="cardMapper.xml.selectbyid"/>
    </resultMap>
    <select id="selectone" parameterType="Integer" resultMap="resultmap">
        select * from person where id=#{id}
    </select>
</mapper>
```

> card类中cardid属性作为了#{id}

###### 修改mybatis-config.xml文件（添加配置）(只写了mapper)

```java
<mappers>
        <mapper resource="cardMapper.xml"/>
        <mapper resource="personMapper.xml"/>
    </mappers>
```

###### 测试用例实践

```java
    @Test
    public void yiduiyi(){
        SqlSession sqlSession;
     String reserous="mybatis-config.xml";
        try {
            Reader reader= Resources.getResourceAsReader(reserous);
            SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);
            sqlSession=sqlSessionFactory.openSession();
            Person person = sqlSession.selectOne("selectone", 2);
            System.out.println(person);
            Card card = sqlSession.selectOne("selectbyid", 1);
            System.out.println(card);
            sqlSession.close();
        } catch (IOException e) {
          e.printStackTrace();
        }
    }
```

###### 结果

```java
Person{id=2, name='常兆海', age=22, sex='男', card=Card{id=1, card='15235466712'}}
Card{id=1, card='15235466712'}
```

##### 提升（mybatis延迟加载的配置）

###### <font color=yellow>注：</font>xml标签是有顺序的

使用mybaits嵌套查询方式进行查询时，使用延迟加载可以在一定程度上降低运行的小号并提升效率（本质：<font color=red>需要这条查询语句的结果才执行这条查询语句</font>），默认不开启，需要在mybatis-config.xml中《setting》中设置

```java
 <settings>
<!--        打开延迟加载开关-->
        <setting name="lazyLoadingEnabled" value="true"/>
<!--        将积极加载改为消息加载，即按需加载-->
        <setting name="aggressiveLazyLoading" value="false"/>
    </settings>
```



##### 嵌套结果方式>一条sql查询多个结果

> select * ,person.id pid,card.id cid  from person ,card  where person.cardid=card.id and person.id=1

1. 编写personMapper.xml
2. 写入mybatis-config.xml文件（同上）
3. 测试用例  

###### personMapper.xml

``` java
<!--    嵌套结果方式-->
    <select id="selectone1" parameterType="Integer" resultMap="resultmap1">
        select * ,person.id pid,card.id cid  from person ,card  where person.cardid=card.id and person.id=#{id}
    </select>
<!--嵌套结果集方式配置一对一映射-->
    <resultMap id="resultmap1" type="org.example.yiduiyi.Person">
        <id property="id" column="pid"/>
        <result property="name" column="name"/>
        <result property="age" column="age"/>
        <result property="sex" column="sex"/>
<!--        一对一映射-->
        <association property="card" javaType="org.example.yiduiyi.Card" >
            <id property="id" column="cid"/>
            <result property="card" column="card"/>
        </association>
    </resultMap>
```

###### 测试用例  

``` java
 @Test
    public void yiduiyi1(){
        SqlSession sqlSession;
        String reserous="mybatis-config.xml";
        try {
            Reader reader= Resources.getResourceAsReader(reserous);
            SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);
            sqlSession=sqlSessionFactory.openSession();
            Person person = sqlSession.selectOne("selectone1", 2);
            System.out.println(person);

            sqlSession.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```

###### 结果

```java
Person{id=2, name='常兆海', age=22, sex='男', card=Card{id=1, card='15235466712'}}
Card{id=1, card='15235466712'}
```

## 一对多查询

### 一对多

```java
class Person{
    xxxxxx；
    Card type;
}
class Card{
    xxxxxx；
    list<Person> names;   
}
```

#### 使用《association》标签实现

>  collection元素下
>
> > ### - 嵌套查询
> >
> > ### -嵌套结果
>
> 两种配置方式

### 嵌套结果方式

>select * from order,user
>where
>user.uid=order.user_id and
>user.uid=1

1. 创建数据库表
2. 编写yiduiduoMapper.xml
3. 写入mybatis-config.xml文件（同上）
4. 创建pojo对象
5. 测试用例

##### 创建数据库表

###### user

| uid（主） | uname |
| --------- | ----- |

###### tb_order

| id（主） | number | user_id(user表uid的外键) |      |
| -------- | ------ | ------------------------ | ---- |

##### 编写yiduiduoMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="yiduiduoMapper.xml">
    <resultMap id="orders" type="org.example.yiduiduo.Users">
        <id property="id" column="uid"/>
        <result property="name" column="uname"/>
<!--        一对多属性的关联-->
        <collection property="orders" ofType="org.example.yiduiduo.Orders" javaType="list">
<!--            对应private List<Orders> orders;里的 属性和属性对应的泛型-->
            <id property="id" column="id"/>
            <result property="number" column="number"/>
        </collection>
    </resultMap>
    <select id="findorders" resultMap="orders" parameterType="Integer">
        SELECT * FROM tb_order,user
        WHERE user.uid=tb_order.user_id AND user.uid=#{id}
    </select>
</mapper>
```

##### 创建pojo对象

###### orders

```java
package org.example.yiduiduo;

public class Orders {
    private int id;//订单id
    private String number;//订单号
//setget tostring
}
```

###### Users

```java
package org.example.yiduiduo;

import java.util.List;

public class Users {
    private int id;
    private String name;
    private List<Orders> orders;//用户关联订单
//setget tostring
}
```

##### 测试用例

```java
/****、
 * 订单系统涉及一对多 ；
 * 一个人里有多哥订单
 */

public class Text {
    @Test
    public void yiduiyi(){
        SqlSession sqlSession;
        String reserous="mybatis-config.xml";
        try {
            Reader reader= Resources.getResourceAsReader(reserous);
            SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);
            sqlSession=sqlSessionFactory.openSession();
            List<Object> findorders = sqlSession.selectList("findorders", 1);
            System.out.println(findorders);

            sqlSession.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

##### 结果

```java
[Users{id=1, name='aaa', orders=[Orders{id=2, number='15235466712'}, Orders{id=3, number='1341195069'}]}]
```

## 多对多查询

### 一对多

```java
class Person{
    xxxxxx；
    list<Card> type;
}
class Card{
    xxxxxx；
    list<Person> names;   
}
```

#### 本质：

> 使用一张中间表来关联
>
>  使用《association》标签实现

##### 创建pojo对象

###### Orders

```java
package org.example.duoduiduo;
import java.util.List;

public class Orders {
    private int id;//订单id
    private String number;//订单号
    private List<Product> products;
//setget tostring
}

```

###### Product

```java
package org.example.duoduiduo;import java.util.List;
//一个订单可以包含多个商品一种商品属于多个订单。
//多对多表关系  需要一个中间表来维护
public class Product {
    private int id;
    private String name;
    private Double price;
    private List<Orders> orders;
//setget tostring
}
```

##### 创建数据库表

###### tb_order

同上用的一个<br>

###### product

| id(主) | name | price |
| ------ | ---- | ----- |

###### ordersinfo

| id（主） | orders_id(tb_order的id的外键) | product_id(product的id的外键) |
| -------- | ----------------------------- | ----------------------------- |



### 嵌套查询

> 根据订单的id查询订单的信息，已经购买的商品的信息
>
> 1. 订单信息：SELECT * FROM tb_order WHERE id=1
> 2. 订单商品信息id：SELECT product_id FROM ordersinfo WHERE orders_id=1（此处的1来自于1.的id＝1）
> 3. 订单商品信息：SELECT * FROM product WHERE id in(
>    SELECT product_id FROM ordersinfo WHERE orders_id=1)

###### duoduiduoMapper1.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="duoduiduoMapper1.xml">
    <select id="findorderbyid" parameterType="Integer"  resultMap="orderwithproduct">
        SELECT * FROM tb_order WHERE id=#{id}
    </select>
    <resultMap id="orderwithproduct" type="org.example.duoduiduo.Orders">
        <id property="id" column="id"/>
        <result property="number" column="number"/>
<!--        商品信息的映射-->
        <collection property="products" javaType="list" ofType="org.example.duoduiduo.Product"
                    column="id"                select="duoduiduoMapper2.xml.finproductbyid"        >
        </collection>
    </resultMap>
</mapper>
```

###### duoduiduoMapper2.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="duoduiduoMapper2.xml">
<select id="finproductbyid" parameterType="Integer" resultType="org.example.duoduiduo.Product" >
    SELECT * FROM product WHERE id in(
        SELECT product_id FROM ordersinfo WHERE orders_id=#{id})
</select>
</mapper>
```

测试

```java
 @Test
    public void duoduiduo(){//嵌套查询
        SqlSession sqlSession;
        String reserous="mybatis-config.xml";
        try {
            Reader reader= Resources.getResourceAsReader(reserous);
            SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);
           sqlSession=sqlSessionFactory.openSession();
            List<Orders> findorderbyid = sqlSession.selectList("findorderbyid", 1);
            System.out.println(findorderbyid);
            sqlSession.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

```



### 嵌套结果

> 多表查询订单 根据订单的id查询订单信息以及购买的商品信息
>
> SELECT tb_order.*, product.* ,
> tb_order.id oid,
> 	product.id pid
> FROM tb_order,
> 							product,
> 							ordersinfo
> 							WHERE  tb_order.id=ordersinfo.orders_id					
> 							AND product.id =ordersinfo.product_id
> 							AND tb_order.id=1
>
> 结果：
>
> 1	1341195069	2	2	方便面	1.50	1	2
> 1	1341195069	2	3	火腿	    2.00	1	3

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="duoduiduoMapper1.xml">
      <select id="findorderbyid2" resultMap="findorderbyid2" parameterType="Integer">
        SELECT tb_order.*, product.* ,
               tb_order.id oid,
               product.id pid
        FROM tb_order,
             product,
             ordersinfo
        WHERE  tb_order.id=ordersinfo.orders_id
          AND product.id =ordersinfo.product_id
          AND tb_order.id=#{id}
    </select>
<resultMap id="findorderbyid2" type="org.example.duoduiduo.Orders">
    <id property="id" column="oid"/>
    <result property="number" column="number"/>
    <collection property="products" javaType="list" ofType="org.example.duoduiduo.Product">
        <id property="id" column="pid"/>
        <result property="name" column="name"/>
        <result property="price" column="price"/>
    </collection>
</resultMap>
</mapper>
```

测试

```java
//    嵌套结果查询
@Test
public void duoduiduo2(){
    SqlSession sqlSession;
    String reserous="mybatis-config.xml";
    try {
        Reader reader= Resources.getResourceAsReader(reserous);
        SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);
        sqlSession=sqlSessionFactory.openSession();
        List<Orders> findorderbyid = sqlSession.selectList("findorderbyid2", 3);
        System.out.println(findorderbyid);
        sqlSession.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

# 关联映射总结：

## 确定步骤：

> 1. 要实现什么结果  要选择什么方式查询 
> 2. 确定对应的数据库，外键连接关系 ，查询语句
> 3. 确定对应的实体类
> 4. <font color=red>编写mapper文件（文件中关键字的含义，用法）</font>
> 5. 编写测试用例；

<association>元素属性

| **属性**    | **说明**                                                     |
| ----------- | ------------------------------------------------------------ |
| property    | 用于指定映射到的实体类对象的属性，与表字段一一对应           |
| column      | 用于指定表中对应的字段                                       |
| javaType    | 用于指定映射到实体对象的属性的类型                           |
| jdbcType    | 用于指定数据表中对应字段的类型                               |
| fetchType   | 用于指定在关联查询时是否启用延迟加载。fetchType属性有lazy和eager两个属性值，默认值为lazy |
| select      | 用于指定引入嵌套查询的子SQL语句                              |
| autoMapping | 用于指定是否自动映射                                         |
| typeHandler | 用于指定一个类型处理器                                       |
